autoload edit-command-line
zle -N edit-command-line
bindkey '^Xe' edit-command-line

#k# Put the current command line into a \kbd{sudo} call
bindkey "^Xs" sudo-command-line

globalias()
{
  emulate -L zsh
  setopt extendedglob
  local MATCH
  LBUFFER="${LBUFFER:s/;;/.,/}"
  zleiab
}

# just type '...' to get '../..'
rationalise-dot() {
local MATCH
if [[ $LBUFFER =~ '(^|/| |     |'$'\n''|\||;|&)\.\.$' ]]; then
  LBUFFER+=/
  zle self-insert
  zle self-insert
else
  zle self-insert
fi
}
zle -N rationalise-dot
bindkey . rationalise-dot
# without this, typing a . aborts incremental history search
bindkey -M isearch . self-insert


## change default abbreviation key
zle -N globalias && bindkey ";;" globalias

## recompile zsh files
src ()
{
autoload -U zrecompile
[ -f ~/.zshrc ] && zrecompile -p ~/.zshrc
[ -f ~/.zshenv ] && zrecompile -p ~/.zshenv
[ -f ~/.zcompdump ] && zrecompile -p ~/.zcompdump
[ -f ~/.zlogin ] && zrecompile -p ~/.zlogin
[ -f ~/.zlogout ] && zrecompile -p ~/.zlogout
[ -f ~/.zprofile ] && zrecompile -p ~/.zprofile
[ -f ~/.zshrc.local ] && zrecompile -p ~/.zshrc.local
[ -f ~/.zshrc.prompt ] && zrecompile -p ~/.zshrc.prompt
zrecompile -p ~/.zshrc.d/*
}

## use the vi navigation keys (hjkl) besides cursor keys in menu completion
bindkey -M menuselect 'h' vi-backward-char        # left
bindkey -M menuselect 'k' vi-up-line-or-history   # up
bindkey -M menuselect 'l' vi-forward-char         # right
bindkey -M menuselect 'j' vi-down-line-or-history # bottom


bindkey "^f"  history-incremental-search-backward


## ctrl-s will no longer freeze the terminal.
/bin/stty erase "^?"

## Set a search path for the cd builtin
cdpath=(.. ~)

## Setup Less
if [ -f ~/bin/lesspipe.sh ]; then
   export LESSOPEN="| ~/bin/lesspipe.sh %s"
   export LESS=' -R '
fi

## grep newest file
grepl()
{
   mygrepstring=
   while [ $# != 0 ]; do
      mygrepstring="$mygrepstring -e $1"
      shift
   done
   egrep -i `echo $mygrepstring` *(D.om[1,1])
}

## grep second newest file
grepll()
{
   mygrepstring=
   while [ $# != 0 ]; do
      mygrepstring="$mygrepstring -e $1"
      shift
   done
   egrep -i `echo $mygrepstring` *(D.om[2,2])
}

## My Aliases

# Fast change of directories:
  alias ..='cd ..'
  alias ...='cd ../..'
  alias ....='cd ../../..'
  alias .....='cd ../../../..'
  alias ......='cd ../../../../..'
  alias .......='cd ../../../../../..'
  alias -g ...='../..'
  alias -g ....='../../..'
  alias -g .....='../../../..'

## global aliases:
alias -g BG='& exit'
alias -g C='|wc -l'
alias -g G='|grep -i'
alias -g H='|head'
alias -g Hl=' --help |& less -r'
alias -g K='|keep'
alias -g L='|less'
alias -g LL='|& less -r'
alias -g M='|most'
alias -g N='&>/dev/null'
alias -g R='| tr A-z N-za-m'
alias -g SL='| sort | less'
alias -g S='| sort'
alias -g T='|tail'
alias -g V='| vim -'


#alias grep='grep --color=auto'
#alias l='ls -hl --color'
#alias la='ls -Ah --color=auto'
#alias ll='ls -Ahl --color'
#alias ls='ls -h --color=auto'
alias h='history 10'
alias hh='history 50'
alias hhh='history 100'
alias m='more'
alias f='find -iname'
alias md='mkdir'
#alias sc='screen -h 10000 -Rd'
alias sc='byobu'
alias q='exit'
alias cl='clear'
alias tmuxlock='tmux setw allow-rename off; tmux rename-window'
alias tmuxunlock='tmux setw allow-rename on'
alias llog="$PAGER /var/log/syslog"   # take a look at the syslog
alias tlog="tailf /var/log/syslog"    # follow the syslog
alias lessl="less *(D.om[1,1])"
alias lessll="less *(D.om[2,2])"

#if  `which multitail | /usr/bin/grep -q multitail`  ; then
if which multitail &> /dev/null; then
    alias tailf="multitail"
    alias mtail="multitail"
    alias taill="multitail *(D.om[1,1])"
else
    alias taill="tailf *(D.om[1,1])"
fi
if [[ "$TERM" != dumb ]]; then
    #a1# List files with colors (\kbd{ls \ldots})
    alias ls="command ls ${ls_options:+${ls_options[*]}}"
    #a1# List all files, with colors (\kbd{ls -la \ldots})
    alias la="command ls -A ${ls_options:+${ls_options[*]}}"
    #a1# List files with long colored list, without dotfiles (\kbd{ls -l \ldots})
    alias ll="command ls -lhA ${ls_options:+${ls_options[*]}}"
    #a1# List files with long colored list, human readable sizes (\kbd{ls -hAl \ldots})
    alias lh="command ls -hAl ${ls_options:+${ls_options[*]}}"
    #a1# List files with long colored list, append qualifier to filenames (\kbd{ls -l \ldots})\\&\quad(\kbd{/} for directories, \kbd{@} for symlinks ...)
    alias l="command ls -lh ${ls_options:+${ls_options[*]}}"
else
    alias la='command ls -A'
    alias ll='command ls -lhA'
    alias lh='command ls -hAl'
    alias l='command ls -lh'
fi

# set PATH so it includes user's private bin if it exists
if [ -d "$HOME/bin" ] ; then
   PATH="$HOME/bin:$PATH"
fi

xsource $ZSHA_BASE/zshrc.prompt $ZSHA_BASE/zshrc.d/*

## END OF FILE #################################################################
